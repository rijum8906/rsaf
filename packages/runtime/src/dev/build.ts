/**
 * This file contains a build function to build the app in dev mode
 */

import { join, normalize } from 'node:path';

import { AppError } from '@rsaf/core';

import { callConfigFile, createBundlers } from '../utils/build.js';
import { DEV_CLIENT_DIR, DEV_SERVER_DIR } from '../utils/constants.js';
import { saveOutputToCache } from '../utils/dev.js';
import { saveTempFile } from '../utils/fs.js';

import { buildCache } from './cache.js';
import { refreshClientPlugin } from './plugin.js';

/**
 * Orchestrates the initial development build and initializes persistent watching.
 * * * This function performs several critical operations:
 * 1. **Configuration**: Resolves the user's project configuration.
 * 2. **Bundler Initialization**: Creates separate {@link Bundler} instances for Client and Server.
 * 3. **Plugin Injection**: Attaches the HMR/Refresh plugin to the Client bundler.
 * 4. **Dual-Build execution**: Runs parallel builds for both environments.
 * 5. **Artifact Persistence**: Saves client assets to memory cache and writes the Server entry point to the disk.
 * 6. **Watcher Start**: Enables incremental rebuilds via esbuild's watch context.
 * * @returns A promise that resolves once the initial build is complete and watchers are active.
 * @throws {@link AppError} If the build fails or required output files are missing.
 */
export async function build(): Promise<void> {
	// Load the user's rsaf.config.ts/js file
	const cfg = await callConfigFile();

	// Initialize specialized bundlers for development
	const { clientBundler, serverBundler } = createBundlers(cfg, 'dev');

	// Inject the Fast Refresh plugin to enable HMR on the client
	clientBundler.addPlugin(refreshClientPlugin);

	/**
	 * Execute initial builds.
	 * Note: These are performed in memory (write: false) as per ESBuildDevConfig.
	 */
	const { outputFiles: cOutputFiles } = await clientBundler.build();
	const { outputFiles: sOutputFiles } = await serverBundler.build();

	if (!cOutputFiles || !sOutputFiles) {
		throw new AppError(`Couldn't build: No output generated by esbuild.`, {
			code: 'BUILD_FAILED',
			category: 'runtime',
		});
	}

	// Persist client-side assets into the internal memory cache for the dev server
	saveOutputToCache(cOutputFiles);

	/**
	 * Handle Server Entry Point:
	 * We extract the generated server-side code and write it to the local cache
	 * so it can be required/executed by the Node.js runtime.
	 */
	const serverAppJs = sOutputFiles[0]?.text;
	if (!serverAppJs) {
		throw new AppError('Server build did not produce an entry point.', {
			code: 'BUILD_FAILED',
			category: 'runtime',
		});
	}

	// Write the Client App logic to the cache directory
	await saveTempFile(
		join(process.cwd(), DEV_CLIENT_DIR, 'App.js'),
		buildCache.require(normalize('App.js')).contents
	);

	// Write the Server App logic to the cache directory
	await saveTempFile(join(process.cwd(), DEV_SERVER_DIR, 'App.js'), serverAppJs);

	/**
	 * Transition to Watch Mode.
	 * This keeps the esbuild context alive for fast incremental rebuilds.
	 */
	await clientBundler.watch();
	await serverBundler.watch();
}
